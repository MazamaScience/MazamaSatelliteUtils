# GOESAOD documentation: https://data.nodc.noaa.gov/cgi-bin/iso?id=gov.noaa.ncdc:C01511
# https://tools-1.airfire.org/Satellite/GOES-16/AODC/


# exerpt from print(nc):
# 
# float geospatial_lat_lon_extent[]   (Contiguous storage)  
#   long_name: geospatial latitude and longitude references
#   geospatial_westbound_longitude: -152.109283447266
#   geospatial_northbound_latitude: 56.7614517211914
#   geospatial_eastbound_longitude: -52.9468803405762
#   geospatial_southbound_latitude: 14.5713396072388
#   geospatial_lat_center: 30.0830020904541
#   geospatial_lon_center: -87.0969543457031
#   geospatial_lat_nadir: 0
#   geospatial_lon_nadir: -75
#   geospatial_lat_units: degrees_north
#   geospatial_lon_units: degrees_east


library(ncdf4)
library(raster)
library(MazamaSpatialUtils)

# load .nc file
file_path <- file.path('../local_data','OR_ABI-L2-AODC-M3_G16_s20190781512186_e20190781514559_c20190781516459.nc')
nc <- ncdf4::nc_open(file_path)

# get geospatial lat lon extent info
lat_lon_extent <- ncatt_get(nc, "geospatial_lat_lon_extent")
ymn <- lat_lon_extent$geospatial_southbound_latitude
ymx <- lat_lon_extent$geospatial_northbound_latitude
xmn <- lat_lon_extent$geospatial_westbound_longitude
xmx <- lat_lon_extent$geospatial_eastbound_longitude

# create AOD raster
aod <- ncvar_get(nc, "AOD")
aod_raster <- raster(t(aod), xmn=xmn, xmx=xmx, ymn=ymn, ymx=ymx,
                     crs=sp::CRS("+proj=geos +h=35786023 +lon_0=-75 +sweep=x +ellps=GRS80")) # info from goes_imager_projection variable in netCDF

# Attempting to recreate plot generated by Panoply (./AOD_in_OR_ABI-L2-AODC-M3_G16_s20190781512186_e20190781514559_c20190781516459.png)
setSpatialDataDir("~/Data/Spatial")
loadSpatialData("USCensusStates")
plot(aod_raster)
plot(USCensusStates, add=TRUE)

# looks as though AOD data is a bit west of where it should be.
# Also, the western most edge of the data is curved in the panolpy image, but
# not here.

# Lets try a different tactic: find the latitude and longitude of each data point
# manually by implementing the algorithm on page 22 of https://www.goes-r.gov/products/docs/PUG-L2+-vol5.pdf
# and then creating a raster object from the data points and their respective
# latitudes and longitudes.

# We can check that the implementation is correct by using the example at the bottom
# of page 22. The example begins with fixed grid coordinates of:

# y(558) = 0.095340 rad
# x(1539) = -0.024052 rad

# Where x = Fixed Grid E/W scan angle in radians and 
# y = Fixed Grid N/S scan angle in radians

# lets begin by using the x and y scale factor and offset to compute the scan angles
# from their indexes.

# x_index <- 1539
# y_index <- 558
# 
# x_att <- ncatt_get(nc, "x")
# y_att <- ncatt_get(nc, "y")
# 
# x <- x_index*x_att$scale_factor + x_att$add_offset
# y <- y_index*y_att$scale_factor + y_att$add_offset

# print(x)
# print(y)
# [1] -0.015148
# [1] 0.096964

# Hmmm, that should have yielded the -0.024052 rad and 0.095340 rad from above.
# I believe the reason it didn't is because the example is using GOES-R east
# data and we have GOES-R west data. We can check this by comparing lambda_0
# (longitude_of_projection_origin) from the example and our data

# example lambda0 = -1.308996939
# our lambda0 = -75

# So yeah, it looks like we have GOES-R west data which has different scale factors
# offsets, and projection parameters than the example does. Good to know.

# UPDATE: Actually, they are the same lambda0, the only difference is units! So
# looks like we do have GOES-R east after all

# We'll have to copy over the parameters from the example to check the implementation
# and then extract the correct parameters from our netCDF when we apply it to our
# data.

# Params from the example

# Fixed Grid N/S scan angle
y <- 0.095340 # rads
# Fixed Grid E/W scan angle
x <- -0.024052 # rads
# radius of equator
r_eq <- 6378137 # meters
# radius of poles
r_pol <- 6356752.31414 # meters
# height of satellite above earth's surface 
perspective_point_height <- 35786023 # meters
# distance from satellite to center of earth
H <- perspective_point_height + r_eq # meters
# longitude of satellite
lambda_0 <- -1.308996939 # rads?

fixedGridToLatLon <- function(x, y, r_eq, r_pol, H, lambda_0,
                              verbose = FALSE) {
  
  # compute satellite coordinates
  a <- (sin(x)^2 + cos(x)^2) * (cos(y)^2 + (r_eq^2/r_pol^2)*sin(y)^2)
  b <- -2*H*cos(x)*cos(y)
  c <- H^2 - r_eq^2
  r_s = (-b - sqrt(b^2 - 4*a*c))/(2*a) # distance from satellite to point P
  s_x = r_s*cos(x)*cos(y)
  s_y = -r_s*sin(x)
  s_z = r_s*cos(x)*sin(y)
  
  # compute latitude
  lat_rad <- atan( (r_eq^2/r_pol^2) * (s_z/sqrt((H-s_x)^2+s_y^2)) )
  lat <- (180*lat_rad)/pi
  
  # compute longitude
  lon_rad <- lambda_0 - atan(s_y/(H-s_x))
  lon <- (180*lon_rad)/pi
  
  if (verbose) {
    print(sprintf("a = %f", a))
    print(sprintf("b = %f", b))
    print(sprintf("c = %f", c))
    print(sprintf("r_s = %f", r_s))
    print(sprintf("s_x = %f", s_x))
    print(sprintf("s_y = %f", s_y))
    print(sprintf("s_z = %f", s_z))
    print(sprintf("lat_rad = %f", lat_rad))
    print(sprintf("lat = %f", lat))
    print(sprintf("lon_rad = %f", lon_rad))
    print(sprintf("lon = %f", lon))
  }
  
  return(data.frame(lon = lon, lat = lat))
}

lat_lon <- fixedGridToLatLon(x = x, y = y, r_eq = r_eq, r_pol = r_pol, H = H, 
                             lambda_0 = lambda_0, verbose = TRUE)

# [1] "a = 1.000061"
# [1] "b = -83921070.032113"
# [1] "c = 1737135756914831.000000"
# [1] "r_s = 37116300.899732"
# [1] "s_x = 36937053.734017"
# [1] "s_y = 892635.198714"
# [1] "s_z = 3532287.690974"
# [1] "lat_rad = 0.590727"
# [1] "lat = 33.846190"
# [1] "lon_rad = -1.478136"
# [1] "lon = -84.690943"

# These results all match up with the example, yay!

# Now we need to use this function to convert our data from Fixed Grid to 
# latitude and longitude, and try and get the result into a Raster object

# First, get x and y and convert them from indexes to Fixed Grid angles using
# the scale factor and offset.

x <- ncvar_get(nc, "x")
y <- ncvar_get(nc, "y")
 
x_att <- ncatt_get(nc, "x")
y_att <- ncatt_get(nc, "y")

x <- x*x_att$scale_factor + x_att$add_offset
y <- y*y_att$scale_factor + y_att$add_offset

# Then get all the projection parameters
proj_params = ncatt_get(nc, "goes_imager_projection")

# radius of equator
r_eq <- proj_params$semi_major_axis # meters
# radius of poles
r_pol <- proj_params$semi_minor_axis # meters
# height of satellite above earth's surface 
perspective_point_height <- proj_params$perspective_point_height # meters
# distance from satellite to center of earth
H <- perspective_point_height + r_eq # meters
# longitude of satellite
lambda_0 <- (proj_params$longitude_of_projection_origin*pi)/180 # rads

xy <- expand.grid(x = x, y = y)

# Produces NaNs, which might be occuring when the scan angles correspond to a point
# that is not on Earth's surface. 
lat_lon <- fixedGridToLatLon(x = xy$x, y = xy$y, r_eq = r_eq, r_pol = r_pol, H = H, 
                             lambda_0 = lambda_0)

# Lets inspect the result to see if it makes sense
# > summary(lat_lon)
#     lat             lon       
# Min.   :14.57   Min.   :-4374  
# 1st Qu.:22.05   1st Qu.:-4324  
# Median :30.09   Median :-4309  
# Mean   :31.01   Mean   :-4311  
# 3rd Qu.:39.37   3rd Qu.:-4296  
# Max.   :56.69   Max.   :-4275  
# NA's   :47188   NA's   :47188  

# Crap. That longitude range is definitely off...

# Ok, lambda_0 was in degrees, had to convert it to radians. Easy fix
# > summary(lat_lon)
#     lat             lon         
# Min.   :14.57   Min.   :-151.65  
# 1st Qu.:22.05   1st Qu.:-102.07  
# Median :30.09   Median : -87.07  
# Mean   :31.01   Mean   : -88.43  
# 3rd Qu.:39.37   3rd Qu.: -73.40  
# Max.   :56.69   Max.   : -52.95  
# NA's   :47188   NA's   :47188  

# Looking a lot better

# I am going to try and drop all the NaN latitudes and longitudes, and the 
# aod values associated with them.

aod <- ncvar_get(nc, "AOD")
aod <- as.numeric(aod)
# remove all aod values corresponding to NaN lat or lon
aod <- aod[!is.na(lat_lon["lat"]) & !is.na(lat_lon["lon"])] 
# remove all NaN lat or lon
lat_lon <- na.omit(lat_lon)

aod_raster <- raster(crs = crs(USCensusStates))
aod_raster <- rasterize(x=lat_lon, y=aod_raster, field=aod)

# getting an error...
# Error in .local(x, values, ...) : 
#   values must be numeric, integer or logical.

