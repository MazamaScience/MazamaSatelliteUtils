---
title: "Exploration: Bluesky and Regridding With Raster"
output:
  html_document: default
---

```{r, echo=FALSE}
knitr::opts_chunk$set(fig.width=8)
```

This notebook documents conversions between bluesky and raster grids.

```{r setup, message=FALSE}
library(raster)
library(PWFSLSmokeModeling)
library(RColorBrewer)
```

```{r load_data}
baseDir <- '~/Projects/Mazama/airfire-nasa-maiac/'
source(paste0(baseDir, 'R/convertGridToRaster.R'))
load(paste0(baseDir, 'localData/Sand_bluesky_CANSAC_6km.RData'))
load(paste0(baseDir, 'localData/Sand_bluesky_CANSAC_2km.RData'))
ws_grid_6km <- Sand_bluesky_CANSAC_6km
ws_grid_2km <- Sand_bluesky_CANSAC_2km
ws_raster_6km <- convertGridToRaster(ws_grid_6km)
ws_raster_2km <- convertGridToRaster(ws_grid_2km)
```

We subset the data slightly, then convert to raster. 

```{r}
slice=76
xlim=c(-122.0, -118.0); ylim=c(33.0, 37.0) # different area
ws_grid_6km_subset1 <- grid_subset(ws_grid_6km, xlim=xlim, ylim=ylim)
ws_grid_2km_subset1 <- grid_subset(ws_grid_2km, xlim=xlim, ylim=ylim)
ws_raster_6km_subset1 <- convertGridToRaster(ws_grid_6km_subset1)
ws_raster_2km_subset1 <- convertGridToRaster(ws_grid_2km_subset1)
```

We plot both versions side by side.

```{r breaks_and_colors, include=FALSE}
breaks <- c(-10000,1,5,10,20,40,90,140,350,525,10000)
red <- c(255,255,255,255,255,255,255,200,150)/255
green <- c(225,195,165,135,105,75,46,2,3)/255
blue <- c(225,195,165,135,105,75,45,3,3)/255
colors <- c('transparent',grDevices::rgb(red=red, green=green, blue=blue))
```

```{r echo=FALSE}
# plot ws_grid_6km and then ws_raster
oldpar <- par(mfrow=c(1,2))
gridMap(ws_grid_6km_subset1, slice=slice, main="CANSAC-6km as ws_grid object")
plot(ws_raster_6km_subset1[[slice]], main="CANSAC-6km as raster", legend=FALSE, col="transparent")
map(database="county", add=TRUE, col="gray80")
map(database="state", add=TRUE)
plot(ws_raster_6km_subset1[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
```

The plots look pretty much identical. But we should zoom in a little further to investigate more closely.

```{r}
xlim=c(-121.8, -120.3); ylim=c(34.8, 36.2)
ws_grid_6km_subset2 <- grid_subset(ws_grid_6km, xlim=xlim, ylim=ylim)
ws_grid_2km_subset2 <- grid_subset(ws_grid_2km, xlim=xlim, ylim=ylim)
ws_raster_6km_subset2 <- convertGridToRaster(ws_grid_6km_subset2)
ws_raster_2km_subset2 <- convertGridToRaster(ws_grid_2km_subset2)
```

```{r echo=FALSE}
par(mfrow=c(1,2))
gridMap(ws_grid_6km_subset2, slice=slice, main="CANSAC-6km as ws_grid object")
plot(ws_raster_6km_subset2[[slice]], main="CANSAC-6km as raster", legend=FALSE, col="transparent")
map(database="county", add=TRUE, col="gray80")
map(database="state", add=TRUE)
plot(ws_raster_6km_subset2[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
```

We see above that the shapes and colors look to be the same, but the pixels look a little smaller along the edges of the plot on the left. Let's look at a much smaller subset to see if we can tell what's going on. I'll also plot the grid bounds as well as the locations of the lat/lon pairs.

```{r}
xlim=c(-120.3, -120.1); ylim=c(33.7, 33.9) # small grid; 4x4

ws_grid_6km_subset3 <- grid_subset(ws_grid_6km, xlim=xlim, ylim=ylim)
ws_grid_2km_subset3 <- grid_subset(ws_grid_2km, xlim=xlim, ylim=ylim)
ws_raster_6km_subset3 <- convertGridToRaster(ws_grid_6km_subset3)
ws_raster_2km_subset3 <- convertGridToRaster(ws_grid_2km_subset3)
```

```{r echo=FALSE}
par(mfrow=c(1,2))
gridMap(ws_grid_6km_subset3, slice=slice, main="CANSAC-6km as ws_grid object")
abline(v=ws_grid_6km_subset3$longitude - ws_grid_6km_subset3$deltaLon/2)
abline(h=ws_grid_6km_subset3$latitude - ws_grid_6km_subset3$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}

plot(ws_raster_6km_subset3[[slice]], main="CANSAC-6km as raster", legend=FALSE, col="transparent")
plot(ws_raster_6km_subset3[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_6km_subset3$longitude - ws_grid_6km_subset3$deltaLon/2)
abline(h=ws_grid_6km_subset3$latitude - ws_grid_6km_subset3$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
```

Now we see the difference. The gridMap on the left cuts off the image based on the bounds of the lat/lon pairs, whereas the raster image on the right shows the entirety of the pixels. But we see the same pattern of colors, which indicates that these plots are displaying the same information. Thus, it appears our `convertGridToRaster()` function is working well, and the differences above are in the display of the information only, not in the information itself.

## Interpolation

One thing we might like to do is compare data from two different grids. The plots above are of the CANSAC 6-km model; a 2-km model also exists. It seems like we should be able to just divide each cell into 9 (3 by 3) to convert from 6-km to 2-km. Let's check it out.

```{r}
factor <- 3
ws_raster_2kfrom6k <- raster(nrow=nrow(ws_raster_6km_subset3)*factor, ncol=ncol(ws_raster_6km_subset3)*factor)
ws_raster_2kfrom6k@extent <- ws_raster_6km_subset3@extent
ws_raster_2kfrom6k <- resample(ws_raster_6km_subset3, ws_raster_2kfrom6k, method='bilinear')
```

The following plot demonstrates our attempt at splitting the 6-km grid into the 2-km grid. We can clearly see that 9 2-km grid cells fit nicely within each 6-km grid cell.

```{r echo=FALSE}

par(mfrow=c(1,2))
plot(ws_raster_6km_subset3[[slice]], main="CANSAC-6km as raster", legend=FALSE, col="transparent")
plot(ws_raster_6km_subset3[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_6km_subset3$longitude - ws_grid_6km_subset3$deltaLon/2)
abline(h=ws_grid_6km_subset3$latitude - ws_grid_6km_subset3$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}

# plot 6km grid interpolated to 2km grid
plot(ws_raster_2kfrom6k[[slice]], main="2km from 6km interpolation\nAttempt 1", legend=FALSE, col="transparent")
plot(ws_raster_2kfrom6k[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
```

Now, we'll duplicate the plot on the right above, but add the actual 2-km grid on top (gray dashed lines and small black dots).

```{r fig.width=4.6, echo=FALSE}
# plot 6km grid interpolated to 2km grid
plot(ws_raster_2kfrom6k[[slice]], main="2km from 6km interpolation\nAttempt 1", legend=FALSE, col="transparent")
plot(ws_raster_2kfrom6k[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```

This doesn't look right. Clearly, the gray boxes are bigger than the colored cells, so our assumed factor of 3 must not be right. Let's figure out the actual factor.

## Interpolation V2

```{r}
ws_grid_6km$deltaLon
ws_grid_2km$deltaLon
(factor <- ws_grid_6km$deltaLon/ws_grid_2km$deltaLon)
```

The calculations above show that the factor from 6-km to 2-km is not 3 as we would expect; it is actually 2.5. So, let's try interpolation according to this factor.

```{r}
ws_raster_2kfrom6k <- raster(nrow=nrow(ws_raster_6km_subset3)*factor, ncol=ncol(ws_raster_6km_subset3)*factor)
ws_raster_2kfrom6k@extent <- ws_raster_6km_subset3@extent
ws_raster_2kfrom6k <- resample(ws_raster_6km_subset3, ws_raster_2kfrom6k, method='bilinear')
```

The code above applies the same extent to the new interpolated 2-km grid as we had in the original 6-km grid, but it splits it into 2.5 2-km grid cells per 6-km grid cell (in one direction). Let's plot the result and see what we see.

The plot on the left is the original 6-km data, with the 6-km bounds and lat/lon pairs shown as before. The plot on the right is the new 2-km data as interpolated from the 6-km grid, as described above (i.e. based on a factor of 2.5).

```{r echo=FALSE}
par(mfrow=c(1,2))
ws_grid_2km_subset3 <- grid_subset(ws_grid_2km, xlim=xlim, ylim=ylim)
plot(ws_raster_6km_subset3[[slice]], main="CANSAC-6km w/ 2km grid overlaid", legend=FALSE, col="transparent")
plot(ws_raster_6km_subset3[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}

# plot 6km grid interpolated to 2km grid
plot(ws_raster_2kfrom6k[[slice]], main="2km from 6km interpolation\nAttempt 2", legend=FALSE, col="transparent")
plot(ws_raster_2kfrom6k[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
```

This looks better at first glance: the colors again seem to line up well with the 6-km map, and we see 5 2-km cells for every 2 6-km cells: a ratio of 2.5 as we expected.

However, we notice trouble when we duplicate the plot on the right above and add the actual 2-km grid cell outlines and centerpoints:

```{r fig.width=4.6, echo=FALSE}
# plot 6km grid interpolated to 2km grid
plot(ws_raster_2kfrom6k[[slice]], main="2km from 6km interpolation\nAttempt 2", legend=FALSE, col="transparent")
plot(ws_raster_2kfrom6k[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```

When we do this we can easily see that the new grid cells (colored squares) still do not perfectly line up with the 2-km grid (dashed gray lines) -- note the slight offset in both directions. So we can see that we need to do the interpolation differently if we want to make comparisons between different models.

## Interpolation V3

Now let's try a different approach. Rather than defining the new grid based on the 6-km grid as before, let's instead base the new grid on the existing 2-km grid. We'll work with the small area as before to keep calculations quick. For this task we leverage the `raster::resample()` function.

```{r}
ws_raster_2kfrom6k_v2 <- resample(ws_raster_6km_subset1, ws_raster_2km_subset3, method='bilinear')
```

Let's plot the results. The plot on the left is the original interpolation, based on our 6-km to 2-km interpolation based on a split of the 6-km grid (i.e. the same as the plot on the right above). The plot on the right is the new approach, in which we have attempted to match the grid cells to the actual 2-km grid locations.

```{r echo=FALSE}
par(mfrow=c(1,2))

plot(ws_raster_2kfrom6k[[slice]], main="2km from 6km interpolation\nAttempt 2", legend=FALSE, col="transparent")
plot(ws_raster_2kfrom6k[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}

plot(ws_raster_6km_subset3[[slice]], col="transparent", axes=FALSE, legend=FALSE, main="2km from 6km interpolation\nAttempt 3")
plot(ws_raster_2kfrom6k_v2[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```

As shown, we now see that the colored squares fit nicely within the dashed gray lines. This is exactly what we have been trying to accomplish. Nice!

## Comparisons

Now that we have 6-km data interpolated onto the same grid as the 2-km model, we should be able to do operations to compare the two.

First let's look at 2-km interpolation vs. actual 2km for the time period.

```{r echo=FALSE}
par(mfrow=c(1,2))

plot(ws_raster_6km_subset3[[slice]], col="transparent", axes=FALSE, legend=FALSE, main="2km from 6km interpolation\nAttempt 3")
plot(ws_raster_2kfrom6k_v2[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}

plot(ws_raster_6km_subset3[[slice]], col="transparent", axes=FALSE, legend=FALSE, main="actual 2km model output")
plot(ws_raster_2km_subset3[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```

Perhaps not surprisingly, these plots do not look very much alike. They are on different grids and represent hour 76 of the forecast.

Let's multiply the 2-km grid by some factor so we get more similar results.

```{r}
ws_raster_2km_subset3 <- ws_raster_2km_subset3*25
```

Now let's plot again and see if that's any better.

```{r echo=FALSE}
par(mfrow=c(1,2))

plot(ws_raster_6km_subset3[[slice]], col="transparent", axes=FALSE, legend=FALSE, main="2km from 6km interpolation\nAttempt 3")
plot(ws_raster_2kfrom6k_v2[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}

plot(ws_raster_6km_subset3[[slice]], col="transparent", axes=FALSE, legend=FALSE, main="actual 2km model output * 25")
plot(ws_raster_2km_subset3[[slice]], col=colors, breaks=breaks, add=TRUE, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```

This isn't a whole lot better, but let's try and work with this. Let's see if we can simply take the difference between these objects.

```{r}
# try to take the difference
diff_2km <- ws_raster_2kfrom6k_v2-ws_raster_2km_subset3
```

Well, it didn't complain too much, and it seems to have worked. A manual double check validates our results:

```{r}
# automatic calculation
head(diff_2km[[slice]]@data@values)
# manual check
head(ws_raster_2kfrom6k_v2[[slice]]@data@values-ws_raster_2km_subset3[[slice]]@data@values)
```

As shown, our first attempt appears to match our manual check. Very good! Let's plot the difference to see if it can tell us anything.

```{r echo=FALSE, fig.width=4.6}
# plot the difference
colors2 <- brewer.pal(11, "PuOr")
plot(ws_raster_6km_subset3[[slice]], col="transparent", axes=FALSE, legend=FALSE, main="diff btwn 2km model and interpolation")
plot(diff_2km[[slice]], col=colors2, add=TRUE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```

Not a whole lot of useful information here, but nice to see the differences graphically. And in case there was any concern about the automatic calculation matching our manual double-check, the plot below shows the difference in the differences to show that they are equal.

```{r echo=FALSE, fig.width=4.6}
plot(ws_raster_6km_subset3[[slice]], col="transparent", axes=FALSE, legend=FALSE, main="diff of differences")
plot(diff_2km[[slice]] - (ws_raster_2kfrom6k_v2[[slice]]@data@values-ws_raster_2km_subset3[[slice]]@data@values), col=colors2, add=TRUE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```


## Small to Big

OK, so we have successfully sampled from a 6-km grid to populate a 2-km grid. Let's see if we can go the other way, from a 2-km grid up to the 6-km grid (note the starting grid has been scaled up as per previous section).

```{r}
ws_raster_6kfrom2k <- resample(ws_raster_2km_subset3, ws_raster_6km_subset3, method='bilinear')
```

```{r echo=FALSE}
par(mfrow=c(1,2))

plot(ws_raster_2km_subset3[[slice]], main="2km model output", col=colors, breaks=breaks, legend=FALSE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}

plot(ws_raster_2km_subset3[[slice]], main="6km from 2km interpolation", col="transparent", legend=FALSE)
plot(ws_raster_6kfrom2k[[slice]], main="6km from 2km interpolation", col=colors, breaks=breaks, legend=FALSE, add=TRUE)
abline(v=ws_grid_2km$longitude - ws_grid_2km$deltaLon/2, lty="dashed", col="gray70")
abline(h=ws_grid_2km$latitude - ws_grid_2km$deltaLat/2, lty="dashed", col="gray70")
abline(v=ws_grid_6km_subset1$longitude - ws_grid_6km_subset1$deltaLon/2)
abline(h=ws_grid_6km_subset1$latitude - ws_grid_6km_subset1$deltaLat/2)
for( lat in ws_grid_6km_subset3$latitude ) { for (lon in ws_grid_6km_subset3$longitude) { points(lon, lat, pch=16, cex=1) }}
for( lat in ws_grid_2km_subset3$latitude ) { for (lon in ws_grid_2km_subset3$longitude) { points(lon, lat, pch=16, cex=.25) }}
```

This is good -- we were able to transfer the 2km grid up to the 6km grid even though the smaller grid doesn't fit perfectly within the larger one. 

## Quick Conversions of Largest Subset

Most of this notebook has been focused on the details of pixel placement and locations. Let's scale up now to look at the first subset shown in the first plot above, converted back and forth between grids.

In the plots below, the first row represents the original grid. The second row shows the new grid, converted from the original. As shown, the raster package does a good job interpolating (or going in reverse) to represent data on a new grid, at least to the point of looking very similar visually.

```{r echo=FALSE, fig.height=8}
par(mfrow=c(2,2))
ws_raster_6km_to_2km_subset2 <- resample(ws_raster_6km_subset2, ws_raster_2km_subset2)
ws_raster_2km_to_6km_subset2 <- resample(ws_raster_2km_subset2, ws_raster_6km_subset2)
plot(ws_raster_6km_subset2[[76]], col=colors, breaks=breaks, legend=FALSE, main="6km model (slice=76)")
plot(ws_raster_2km_subset2[[40]], col=colors, breaks=breaks, legend=FALSE, main="2-km model (slice=40)")
plot(ws_raster_6km_to_2km_subset2[[76]], col=colors, breaks=breaks, legend=FALSE, main="6km to 2-km interpolation")
plot(ws_raster_2km_to_6km_subset2[[40]], col=colors, breaks=breaks, legend=FALSE, main="2km to 6-km interpolation")
```

Looks good! So we have lots of flexibility for fast conversions between model grid sizes. This will come in very handy for doing analysis of MAIAC swath data against bluesky model runs.