---
title: "Intro to GOES AODC Data"
author: "Mazama Science"
date: "7/30/2019"
output: html_document
vignette: >
  %\VignetteIndexEntry{Intro to GOES AODC Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Aerosol Optical Depth
Aerosol optical depth provides a measure of air quality by estimating the amount
of particles in a vertical column of the atmosphere. The absorbtion and 
scattering of certain spectral wavelengths on the atmosphere is fed into aerosol
models to determine an AOD value. This number is unitless, but values closer to 
0.0 correspond to a cleaner atmosphere while higher values correspond to more 
hazy conditions. An average AOD for the U.S. is usually around 0.1 and 0.15.

There are limitations to this method though. Sunlight is required for the
measurement process, meaning that AOD levels can't be estimated during 
nighttime. Additionally, many areas will have no AOD defined due to the 
reflectance of underlying clouds or snow.

## AOD Source
The MazamaSatelliteUtils package uses AOD data provided by the Advanced 
Baseline Imager ([ABI](https://www.goes-r.gov/spacesegment/abi.html)) on board 
the GOES-16 satellite. This geostationary satellite is positioned to give the 
ABI a full view of the lower 48 states, and about every 5 minutes the imager
can complete a full scan of this region. Each individual scan is saved to its 
own NetCDF file.

More on the ABI's AOD measurement process can be found in the 
[GOES-R aerosol optical depth overview](https://www.star.nesdis.noaa.gov/goesr/product_aero_aod.php)
and the
[ABI AOD algorithm theoretical basis document](https://www.star.nesdis.noaa.gov/goesr/docs/ATBD/AOD.pdf).

## NetCDF Files
The "Common Data Form" filetype is used for efficient access to multidimensional
array-based data such as atmospheric measurements. A typical scan of North 
America holds 3,750,000 readings per variable, resulting in a file of around 3 
to 4 MB. If scans are taken every 5 minutes, a single day would hold about
12 files * 24 hrs * 3 MB = 860 MB worth of data. Due to this fairly large size, 
downloading a NetCDF saves the file to a specified data directory from which the
contents can be accessed through a file handle.

## MazamaSatelliteUtils Setup
Let's start exploring AOD data with the `MazamaSatelliteUtils` package. Let's
first give ourselves a case study to focus, such as the recent Milepost 97 Fire.
This incident was reported on July 24, 2019 about 1 mile southeast of 
Canyonville, Oregon and is still current as of August 11, 2019. This should 
provide plenty of data for us to examine in detail.

To begin our analysis, let's load the MazamaSatelliteUtils package and define a 
`SatelliteDataDir`: A directory where all our NetCDF files will be stored to and
read from:

```{r satellite_setup, message=FALSE}
library(MazamaSatelliteUtils)
setSatelliteDataDir("~/Data/Satellite")
```

## Downloading Data and Creating NetCDF Handles
We can now start loading in some satellite data using the `goesaodc_downloadAOD`
package function. Here we have to provide a datetime to specify which files we 
want. If the datetime is defined to the hour, then all of the NetCDF files 
generated in that hour will be downloaded. If just the date is given with no 
time specified, then all files generated during that entire day will be fetched.
In either case, any downloaded files will be stored in the `SatelliteDataDir` we
just defined.

Since downloading NetCDF files can take a bit of time, let's just gather data 
for August 1, 2019 at 16:00:00 UTC (9AM PDT).

```{r download_files}
datetime <- lubridate::ymd_h("2019-08-01 16", tz = "UTC")
downloadedFiles <- goesaodc_downloadAOD(datetime)
```

The `goesaodc_downloadAOD()` function also returns a vector of paths to each 
downloaded file. However, if a file already exists in the `SatelliteDataDir` 
directory then it will not be downloaded again and will not show up in the 
returned vector. We can see which files are now availible to read by calling 
`goesaodc_listFiles()` on the datetime we specified:

```{r display_files}
dateFiles <- goesaodc_listFiles(datetime)
print(dateFiles)
```

In order to read the contents of a NetCDF file we will need a handle to access 
it by. This can be done by calling `goesaodc_openFile()` on the dataset 
filename, so let's just open the first one in our downloaded time range 
`dateFiles[1]`:

```{r load_handle}
nc <- goesaodc_openFile(filename = dateFiles[1])
```

## netCDF Handle Functions

Now that we have a handle (class `ncdf4`) to a netCDF file we can start 
exploring how this dataset is structured.

```{r handle_elements}
names(nc)
```

Here is a brief rundown of the various top level elements in these `ncdf4` 
objects:

1. `filename` - A character string containing the name of the file.
2. `writeable` - Logical stating whether or not the file can be written to. This 
will always be `FALSE` when the file is loaded through `goesaodc_openFile()`.
3. `ndims` - The number of dimensions in the file.
4. `nvars` - The number of variables in the file that are not dimensional
variables.
5. `natts` - The number of global attributes.
6. `unlimdimid` - The unlimited dimension id. -1 if there is none.

At this point we can freely access any of the `r nc$nvars` variables in the 
dataset (listed by `names(nc$var)`) using the `ncvar_get()` 
function provided through `ncdf4`.

```{r ncdf4_retrival}
readings_aod <- as.numeric(ncdf4::ncvar_get(nc, "AOD"))
print(length(readings_aod))
print(range(readings_aod, na.rm = TRUE))
```

## AOD Data as a Tibble

For our purposes of mapping AOD values, we can consolidate all the data we 
need (longitude, latitude, and AOD) and make it even easier to access by forming
it into a tibble with the function `goesaodc_createTibble()`. The "DQF" variable
is included as well, which represents the data quality flag for each reading. 
This flag can take one of the four following values 
([source p.295](https://www.goes-r.gov/products/docs/PUG-L2+-vol5.pdf)):

* 0 - High quality
* 1 - Medium quality
* 2 - Low quality
* 3 - No retrieval flag

```{r create_tibble}
tb <- goesaodc_createTibble(nc)
knitr::kable(head(tb))
```

## Working With Data as SpatialPoints

The next step is actaully visualizing this data on geographic maps by creating 
and plotting spatial points from the AOD readings:

```{r spatialPlot_world}
sp <- goesaodc_createSpatialPoints(nc)

maps::map("world")
goesaodc_plotSpatialPoints(sp, add = TRUE, cex = 0.2)
```

Since the GOES-16 satellite is geosynchrous, it can only provide scans over a 
portion of the Americas. Let's zoom in to just the U.S. readings by defining the 
`database` for the underlying map:

```{r spatialPlot_usa}
maps::map(database = "state")
goesaodc_plotSpatialPoints(sp, add = TRUE, cex = 0.2)
```

The desired quality of the data can also be specified when creating the spatial 
points. Defining the `dqfLevel` includes all points that are *at and below* 
the given level. Let's look at all of the points at level 0 (highest quality):

```{r spatialPlot_high_quality}
sp_dqf0 <- goesaodc_createSpatialPoints(nc, dqfLevel = 0)

maps::map("state")
goesaodc_plotSpatialPoints(sp_dqf0, add = TRUE, cex = 0.2)
```

As you can see, quite a bit of data has been removed since a good portion of it 
was marked as only medium or low quality.

## Working With Data as a Raster

Lastly, we can generate raster objects for each netCDF file. These can be 
plotted and mapped over.

```{r create_raster_highdef}
rstr <- goesaodc_createRaster(nc)

raster::plot(rstr, "AOD")
maps::map("state", add = TRUE)
```

The resolution of these rasters can be set with the `res` parameter. Values
closer to zero increase the image resolution while larger values decrease it and
produce more 'blocky' pictures (but are faster to generate). The resolution is 
set to 0.1 by default, but let's try a slightly higher value:

```{r create_raster_lowdef}
rstr_lowdef <- goesaodc_createRaster(nc, res = 0.5)

raster::plot(rstr_lowdef, "AOD")
maps::map("state", add = TRUE)
```

```{r spatial_setup}
library(MazamaSpatialUtils)
setSpatialDataDir("~/Data/Spatial")
loadSpatialData("USCensusStates")
```

## AOD Over Time
One benefit of deploying many unique monitors on ground level is that it is very
easy to retrieve time series data from specific, fixed locations. There is only 
one ABI, however, and the locations it scans aren't uniquely nor consistently 
identified between scans which makes tracking over time more difficult. 
Rasterizing helps solve this problem since the grid cells are always fixed 
between scans and can be queried easily by finding the cells close to the
desired coordinates.

So far we have created plots for AOD points from just one netCDF file at a 
time, however, the `MazamaSatelliteUtils` package also provides functions to 
visualize readings between multiple netCDFs over a given hour. The first of 
these is the `goesaodc_createRasterStack` function, which can be used to 
generate a stack of RasterBricks to be plotted together. The second is the 
`goesaodc_createHourlyAverageRaster` function, which can be used to visualize 
the "average" AOD for a state over a given hour.