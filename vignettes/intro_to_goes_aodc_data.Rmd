---
title: "Intro to GOES AODC Data"
author: "Mazama Science"
date: "7/30/2019"
output: html_document
vignette: >
  %\VignetteIndexEntry{Intro to GOES AODC Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This vignette will cover the basics of working with aerosol optical depth (AOD) 
readings from the GOES-16 Geostationary Opertational Environmental Satellite. 

Aerosol optical depth is a measure of the amount of particles in a vertical 
column of the atmosphere. The measurement is unitless, but values closer to 0.00 
correspond to fewer particles (a cleaner atmosphere) while higher values 
correspond to hazy conditions. An average AOD for the U.S. would usually lie 
between 0.1 and 0.15. The value itself is related to the scattering and 
absorbition of certain light waves on the atmosphere, measured by the Advanced 
Baseline Imager ([ABI](https://www.goes-r.gov/spacesegment/abi.html)) on board 
the GOES-16 satellite. More on this process can be found 
[here](https://www.star.nesdis.noaa.gov/goesr/product_aero_aod.php).

[More on GOES AOD on page 272](https://www.goes-r.gov/products/docs/PUG-L2+-vol5.pdf)

## Package Setup and Dependencies

Due to the size of the spatial mapping and aerosol reading datasets, we must
first set which directories will hold this information.

```{r setup_dependencies, message=FALSE}
library(MazamaSatelliteUtils)
setSatelliteDataDir("~/Data/Satellite")
```

## Downloading Data and Creating netCDF Handles

GOES data is stored as an individual netCDF file for each time sample. 
Downloading these files does not load them as objects in the R environment, but
instead saves them to the `SatelliteDataDir` directory where they can be opened 
individually through their netCDF handles. In this example, let's take a look at 
data read throughout hour 16:00 UTC on May 16, 2019:

```{r download_data}
date <- lubridate::ymd_h("2019-05-16 16", tz = "UTC")
downloadedFiles <- goesaodc_downloadAOD(date)
```

If an hour is not specified, then every file generated over the given day will
be downloaded. The `goesaodc_downloadAOD()` function also returns a vector of
paths to each downloaded file. However, if a file already exists in the 
`SatelliteDataDir` directory then it will not be downloaded again. We can see 
which which files are now availible to read by calling `goesaodc_listFiles()` on
the date we defined.

```{r display_downloaded_files}
dateFiles <- goesaodc_listFiles(date)
print(dateFiles)
```

To read one of these netCDF datasets we need a handle to access it by. This 
can be done by calling `goesaodc_openFile()` on one of the filenames, so let's
open the first one in our time range `dateFiles[1]`:

"`r dateFiles[1]`"

```{r load_handle}
nc <- goesaodc_openFile(filename = dateFiles[1])
```

## netCDF Handle Functions

Now that we have a handle (class 'ncdf4') to a netCDF file we can start 
exploring how this data format is structured.

```{r handle_elements}
names(nc)
```

Here is a brief rundown of the various top level elements in these ncdf4 
objects:

1. `filename` - A character string containing the name of the file.
2. `writeable` - Logical stating whether or not the file can be written to. This 
will always be `FALSE` when the file is loaded through `goesaodc_openFile()`.
3. `ndims` - The number of dimensions in the file.
4. `nvars` - The number of variables in the file that are not dimensional
variables.
5. `natts` - The number of global attributes.
6. `unlimdimid` - The unlimited dimension id. -1 if there is none.

At this point we can freely access any of the `r nc$nvars` variables in the 
dataset (listed by `names(nc$var)`) using the `ncvar_get()` 
function from `ncdf4`.

```{r ncdf4_retrival}
readings_aod <- as.numeric(ncdf4::ncvar_get(nc, "AOD"))
print(length(readings_aod))
print(range(readings_aod, na.rm = TRUE))
```

## Working With Data as a Tibble

For our purpose of mapping DOA values, we can consolidate all the data we 
need (longitude, latitude, and DOA) and make it easy to access by forming it 
into a tibble with the function `goesaodc_createTibble()`. The "DQF" variable is
included as well, as it represents the data quality flag for each reading. This
flag can take one of the four following values 
([source p.295](https://www.goes-r.gov/products/docs/PUG-L2+-vol5.pdf)):

* 0 - High quality retrieval QF
* 1 - Medium quality retrieval QF
* 2 - Low quality retrieval QF
* 3 - No retrieval QF

```{r create_tibble}
tb <- goesaodc_createTibble(nc)
knitr::kable(head(tb))
```

## Working With Data as SpatialPoints

The next step is actaully visualizing this information on geographic maps by
creating spatialPoints from the DOA readings:

```{r spatialPlot_world}
maps::map("world")

sp <- goesaodc_createSpatialPoints(nc)
goesaodc_plotSpatialPoints(sp, add = TRUE, cex = 0.2)
```

We can zoom in using the `xlim` and/or `ylim` parameters for `map()` or by 
setting the `database`:

```{r spatialPlot_usa}
maps::map(database = "state")
goesaodc_plotSpatialPoints(sp, add = TRUE, cex = 0.2)
```

The quality level of the data can also be specified when creating the spatial 
points. This includes all points that are *at and below* the specified level. 
Let's look at all of the points at level 0, the ones flagged for the highest 
quality:

```{r spatialPlot_high_quality}
sp_dqf0 <- goesaodc_createSpatialPoints(nc, dqfLevel = 0)
maps::map("state")
goesaodc_plotSpatialPoints(sp_dqf0, add = TRUE, cex = 0.2)
```

Quite a bit of data has been removed since a good portion of it was marked only
as medium or low quality.

## Working With Data as a Raster

Lastly, we can generate raster objects for each netCDF file. These can be 
plotted and mapped over.

```{r create_raster_highdef}
raster <- goesaodc_createRaster(nc)
raster::plot(raster, "AOD")
maps::map("state", add = TRUE)
```

The resolution of these rasters can be set with the `res` parameter. Values
closer to zero increase the image resolution while larger values decrease it and
produce more 'blocky' pictures (but are faster to generate). The resolution is 
set to 0.1 by default, but let's try a slightly higher value:

```{r create_raster_lowdef}
raster <- goesaodc_createRaster(nc, res = 0.5)
raster::plot(raster, "AOD")
maps::map("state", add = TRUE)
```