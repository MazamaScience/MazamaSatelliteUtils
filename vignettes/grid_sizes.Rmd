---
title: "Grid Sizes"
author: "Mazama Science"
date: "8/2/2019"
output: html_document
vignette: >
  %\VignetteIndexEntry{Grid Sizes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(MazamaSatelliteUtils)
library(MazamaSpatialUtils)

setSatelliteDataDir("~/Data/Satellite")
setSpatialDataDir("~/Data/Spatial")

# get bbox for Texas
loadSpatialData("USCensusStates")
tx <- subset(USCensusStates, stateCode == "TX")
bb_tx <- sp::bbox(tx)

nc <- goesaodc_openFile("OR_ABI-L2-AODC-M6_G16_s20191291201274_e20191291204047_c20191291210009.nc")
pal <- colorRampPalette(c("khaki", "orangered"))
```

Creating a raster image divides geographic space into uniform tiles or pixels.
The resolution of the raster image defines how much world space each tile 
accounts for, so larger tiles cover a larger area and (usually) more data 
points. A whole new tile will be created for an area whether there is just one 
or several hundred points. This raises raises two issues:

1. When a large area is sparsely populated, the entire tile will be defined 
by just those few values which might not accurately represent the whole area.

2. When a large area is densly populated, the tile will have to 
summarize all of the values in order to determine its single color. This may not
accurately depict potential disparities in AOD throughout the area.

In this vignette we will be analyzing raster grids for these different 
scenarios. A good place to find areas of both types is Texas on ?????, where the 
sea just off the east coast is dense with data points as opposed to the more 
sparse western half of the state:

```{r plot_texas_points, echo=FALSE}
tb <- goesaodc_createTibble(nc)
bbox_tx <- c(-107, -93, 26, 37)
data_tx <- dplyr::filter(tb, lon > bbox_tx[1], lon < bbox_tx[2], 
                         lat > bbox_tx[3], lat < bbox_tx[4])

plot(tx)
points(data_tx$lon, data_tx$lat, pch = 16, cex = 0.1)
```

To display the differences in resolutions, here are three rasters with 
resolutions 0.1, 0.3, and 1.0 respectively:

```{r display_different_resolutions, echo=FALSE}
par(mfrow=c(1, 3))
rstr <- goesaodc_createRaster(nc, bbox = bb_tx, res = 0.1)
raster::plot(rstr, "AOD Res. 0.1", col = pal(100), legend = FALSE)
plot(tx, add = TRUE)

rstr <- goesaodc_createRaster(nc, bbox = bb_tx, res = 0.3)
raster::plot(rstr, "AOD Res. 0.3", col = pal(100), legend = FALSE)
plot(tx, add = TRUE)
  
rstr <- goesaodc_createRaster(nc, bbox = bb_tx, res = 1.0)
raster::plot(rstr, "AOD Res. 1.0", col = pal(100), legend = FALSE)
plot(tx, add = TRUE)
```

As the tiles increase in size they become more and more inaccurate in summarizing
the true AOD values over the area they cover. Let's start analyzing the two 
cases from earlier though, starting with the very dense cloud of points off the
east coast, near Corpus Christi:

```{r plot_dense_area, fig.width=10, fig.height=7, fig.align='center', echo=FALSE}
# Subset for the east coast of Texas where there is a lot of dense data
bb_tx_dense <- c(-97, -96, 27, 28)
tb_tx_dense <- dplyr::filter(tb, 
                             lon > bb_tx_dense[1], lon < bb_tx_dense[2], 
                             lat > bb_tx_dense[3], lat < bb_tx_dense[4])
rstr <- goesaodc_createRaster(nc, 
                              lonLo = bb_tx_dense[1], lonHi = bb_tx_dense[2], 
                              latLo = bb_tx_dense[3], latHi = bb_tx_dense[4], 
                              res = 0.1, fun = mean)

# Define the AOD color palette
pal_aod <- colorRampPalette(c("khaki", "orangered"))

# Plot the raster colored with the AOD palette and draw all sample point locations
raster::plot(rstr, "AOD", col = pal_aod(25), xlim = bb_tx_dense[1:2], ylim = bb_tx_dense[3:4])
plot(tx, add = TRUE)
points(tb_tx_dense$lon, tb_tx_dense$lat, pch = 16, cex = 0.6, col = "black")
```

Drawing the sample points now with the same palette shows how the raster 
generalizes AOD readings for each tile:

```{r, fig.width=10, fig.height=7, fig.align='center', echo=FALSE}
# Assign each reading its own color based on the AOD palette
tb_tx_dense$col <- pal_aod(25)[as.numeric(cut(tb_tx_dense$AOD, breaks = 25))]

# Plot the raster and points, both now with the same AOD palette
raster::plot(rstr, "AOD", col = pal_aod(25), xlim = bb_tx_dense[1:2], ylim = bb_tx_dense[3:4])
plot(tx, add = TRUE)
points(tb_tx_dense$lon, tb_tx_dense$lat, pch = 16, cex = 0.6, col = tb_tx_dense$col)
```
