#' @export
#'
#' @title Create a daytime RasterStack for a specified date
#'
#' @param startdate startdate in any Y-m-d format or \code{POSIXct}
#' @param longitude longitude of the location.
#' @param latitude latitude of the location.
#' @param var variable ("AOD, "DQF" or "ID")
#' @param res resolution of raster in degrees
#' @param fun use when rasterizing. Not currently supported, defaults to mean.
#' @param bbox bounding box generated by \code{sp::bbox}. Overrides lonLo, lonHi
#' latLo, latHi if provided
#' @param lonLo lower longitude extent
#' @param lonHi upper longitude extent
#' @param latLo lower latitude extent
#' @param latHi upper latitude extent
#' @param dqfLevel data quality flag level, numeric (0, 1, 2, or 3)
#'
#' @description Create a \code{RasterStack} from GOES AOD data files for the
#' date specified by \code{startdate}. Each \code{RasterLayer} contains
#' data from one Advanced Baseline Imager (ABI) scan during the specified time
#' period.
#'
#' If data for the specified time period is not found in the directory specified
#' by \code{setSatelliteDataDir()}, it will be downloaded in order to create the
#' \code{RasterStack}.
#'
#' The Z axis of the \code{RasterStack} is a character vector where each element
#' is the time stamp of the scan and has the format YYYYMMDDHHMMSS. This can be
#' accessed using the \code{raster::getZ()} function. Names of the
#' \code{RasterStack} are also time stamps of the scan, of the format XHH.MM.SS.
#'
#' Data quality level `dqfLevel` can take a value of:
#'
#' 0: High quality retrieval flag
#' 1: Medium quality retrieval flag
#' 2: Low quality retrieval flag
#' 3: No retrieval quality flag
#'
#' @return RasterStack
#'
#' @examples
#' \dontrun{
#' library(MazamaSatelliteUtils)
#' library(MazamaSpatialUtils)
#'
#' setSatelliteDataDir("~/Data/Satellite")
#' setSpatialDataDir("~/Data/Spatial")
#' loadSpatialData("USCensusStates")
#'
#' # Define the region of interest (Milepost 97 Fire in Oregon)
#' oregon <- subset(USCensusStates, stateCode == "OR")
#' bbox_oregon <- sp::bbox(oregon)
#' longitude <- -123.245
#' latitude <-   42.861
#'
#' dateLocal <- lubridate::ymd("2019-08-01", tz = "America/Los_Angeles")
#'
#' dayStack <- goesaodc_createDaytimeRasterStack(dateLocal,
#'                                               longitude = -123.32,
#'                                               latitude = 42.88,
#'                                               bbox = bbox_oregon)
#' tb <- raster_createLocationTimeseries(dayStack,
#'                                       longitude = longitude,
#'                                       latitude = latitude,
#'                                       bbox = bbox_oregon)
#'
#' plot(x = tb$datetime, y = tb$aod,
#'      pch = 15, cex = 0.8, col = rgb(red = 0, green = 0, blue = 0, alpha = 0.8),
#'      main = dateLocal, xlab = "Time (PDT)", ylab = "AOD")
#' }

goesaodc_createDaytimeRasterStack <- function(
  startdate = NULL,
  longitude = NULL,
  latitude = NULL,
  var = "AOD",
  res = 0.1,
  fun = mean,
  bbox = NULL,
  lonLo = NULL,
  lonHi = NULL,
  latLo = NULL,
  latHi = NULL,
  dqfLevel = NULL
) {
  
  # Convert the local date to a UTC date
  # UPDATE THIS TO USE MazamaCoreUtils::parseDatetime
  dateUTC <- lubridate::with_tz(startdate, tzone = "UTC")
  
  timezone <- MazamaSpatialUtils::getTimezone(longitude, latitude,
                                              countryCodes = c("US"))
  
  # Then gather local timeinfo from that UTC date
  dateInfo <- PWFSLSmoke::timeInfo(dateUTC,
                                   longitude = longitude,
                                   latitude = latitude,
                                   timezone = timezone)
  
  # Now that we have the local sunrise and sunset times for the date we convert
  # them back to UTC times
  sunriseUTC <- lubridate::with_tz(dateInfo$sunrise, tzone = "UTC")
  sunsetUTC <- lubridate::with_tz(dateInfo$sunset, tzone = "UTC")
  
  # Round and contract the boundary hours
  sunriseHourUTC <- lubridate::ceiling_date(sunriseUTC, unit = "hour")
  sunsetHourUTC <- lubridate::floor_date(sunsetUTC, unit = "hour")
  
  # Get all the UTC hours between the local sunrise and sunset hours
  hours <- seq.POSIXt(from = sunriseHourUTC, to = sunsetHourUTC, by = "hour")
  hours <- strftime(hours, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
  
  # TODO: Determine proper satellite
  satId <- "G16"
  
  # Create a rasterStack for each hour and add them all to one "day" rasterStack
  dayStack <- raster::stack()
  for (hour in hours) {
    result <- try({
      hourStack <- goesaodc_createHourlyRasterStack(satId = satId,
                                                    startdate = hour,
                                                    var = var,
                                                    res = 0.1,
                                                    fun = fun,
                                                    bbox = bbox,
                                                    lonLo = lonLo,
                                                    lonHi = lonHi,
                                                    latLo = latLo,
                                                    latHi = latHi,
                                                    dqfLevel = dqfLevel)
      
      # Combine the rasters and timestamps of the day and hour stacks
      zDay <- raster::getZ(dayStack)
      zHour <- raster::getZ(hourStack)
      
      dayStack <- raster::stack(dayStack, hourStack)
      dayStack <- raster::setZ(dayStack, c(zDay, zHour))
    }, silent = TRUE)
    
    if ("try-error" %in% class(result)) {
      stop(result)
    } else {
      print(paste0("Stacked hour: ", hour))
    }
  }
  
  return(dayStack)
  
}
