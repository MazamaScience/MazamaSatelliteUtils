#' @export
#' 
#' @title Create a daytime RasterStack for a specified date
#' 
#' @param startdate startdate in any Y-m-d format or \code{POSIXct}
#' @param timezone the timezone to determine the sunrise and sunset times
#' @param var variable ("AOD, "DQF" or "ID")
#' @param res resolution of raster in degrees
#' @param fun function to use when rasterizing. Not currently supported, defaults
#' to mean.
#' @param bbox bounding box generated by \code{sp::bbox}. Overrides lonLo, lonHi
#' latLo, latHi if provided
#' @param lonLo lower longitude extent
#' @param lonHi upper longitude extent
#' @param latLo lower latitude extent
#' @param latHi upper latitude extent
#' @param dqfLevel data quality flag level, numeric (0, 1, 2, or 3)
#' 
#' @description Create a \code{RasterStack} from GOES AOD data files for the 
#' date specified by \code{startdate}. Each \code{RasterLayer} contains
#' data from one Advanced Baseline Imager (ABI) scan during the specified time 
#' period.
#' 
#' If data for the specified time period is not found in the directory specified 
#' by \code{setSatelliteDataDir()}, it will be downloaded in order to create the
#' \code{RasterStack}.
#' 
#' The Z axis of the \code{RasterStack} is a character vector where each element
#' is the time stamp of the scan and has the format YYYYMMDDHHMMSS. This can be 
#' accessed using the \code{raster::getZ()} function. Names of the 
#' \code{RasterStack} are also time stamps of the scan, of the format XHH.MM.SS.
#' 
#' Data quality level `dqfLevel` can take a value of:
#' 
#' 0: High quality retrieval flag
#' 1: Medium quality retrieval flag
#' 2: Low quality retrieval flag
#' 3: No retrieval quality flag
#' 
#' @return RasterStack
#' 
#' @examples
#' \dontrun{
#' library(MazamaSatelliteUtils)
#' library(MazamaSpatialUtils)
#' 
#' setSatelliteDataDir("~/Data/Satellite")
#' setSpatialDataDir("~/Data/Spatial")
#' loadSpatialData("USCensusStates")
#' 
#' # Define the region of interest (Milepost 97 Fire in Oregon)
#' oregon <- subset(USCensusStates, stateCode == "OR")
#' bbox_oregon <- sp::bbox(oregon)
#' lon <- -123.245
#' lat <-   42.861
#' 
#' dateLocal <- lubridate::ymd("2019-08-01", tz = "America/Los_Angeles")
#' 
#' dayStack <- goesaodc_createDaytimeRasterStack(dateLocal, "America/Los_Angeles",
#'                                             bbox = bbox_oregon)
#' tb <- raster_createLocationTimeseries(dayStack, 
#'                                       longitude = lon, latitude = lat, 
#'                                       bbox = bbox_oregon)
#' 
#' plot(x = tb$datetime, y = tb$aod, 
#'      pch = 15, cex = 0.8, col = rgb(red = 0, green = 0, blue = 0, alpha = 0.8),
#'      main = dateLocal, xlab = "Time (PDT)", ylab = "AOD")
#' }

goesaodc_createDaytimeRasterStack <- function(
  startdate = NULL,
  timezone = "UTC",
  var = "AOD",
  res = 0.1,
  fun = mean,
  bbox = NULL,
  lonLo = NULL,
  lonHi = NULL,
  latLo = NULL,
  latHi = NULL,
  dqfLevel = NULL
) {
  
  # Convert the local date to a UTC date
  dateUTC <- startdate
  attributes(dateUTC)$tzone <- "UTC"
  
  # Then gather local timeinfo from that UTC date
  dateInfo <- PWFSLSmoke::timeInfo(dateUTC, 
                                   longitude = lon, 
                                   latitude = lat, 
                                   timezone = timezone) 
  
  # Finally, now that we have the local sunrise and sunset times for the date we 
  # convert them back to UTC times
  sunriseUTC <- dateInfo$sunrise
  sunsetUTC <- dateInfo$sunset
  attributes(sunriseUTC)$tzone <- "UTC"
  attributes(sunsetUTC)$tzone <- "UTC"
  
  # Round and contract the boundary hours
  sunriseHourUTC <- lubridate::ceiling_date(sunriseUTC, unit = "hour")
  sunsetHourUTC <- lubridate::floor_date(sunsetUTC, unit = "hour")
  
  # Get all the UTC hours between the local sunrise and sunset hours
  hours <- seq.POSIXt(from = sunriseHourUTC, to = sunsetHourUTC, by = "hour")
  hours <- strftime(hours, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
  
  # Create a rasterStack for each hour and add them all to one "day" rasterStack
  dayStack <- raster::stack()
  for (hour in hours) {
    result <- try({
      hourStack <- goesaodc_createHourlyRasterStack(startdate = hour,
                                                    var = var,
                                                    res = 0.1,
                                                    fun = fun,
                                                    bbox = bbox,
                                                    lonLo = lonLo,
                                                    lonHi = lonHi,
                                                    latLo = latLo,
                                                    latHi = latHi,
                                                    dqfLevel = dqfLevel)
      
      # Combine the rasters and timestamps of the day and hour stacks
      zDay <- raster::getZ(dayStack)
      zHour <- raster::getZ(hourStack)
      
      dayStack <- raster::stack(dayStack, hourStack)
      dayStack <- raster::setZ(dayStack, c(zDay, zHour))
    }, silent = TRUE)
    
    print(paste0("Stacked hour: ", hour))
  }
  
  return(dayStack)
  
}